---
layout: db
date: 2021-10-22 19:09:46
title: 'Adatb - 4. gyakorlat'
lead: 'Lek√©rdez√©sek optimaliz√°l√°sa - a fizikai ismeretek b≈ëv√≠t√©se'
tags: ['adatb', 'optimaliz√°l√°s', 'algoritmusok']
comment: true
featuredImage: null
---

# Tartalomjegyz√©k

```toc
# This code block gets replaced with the TOC
exclude: Tartalomjegyz√©k
to-heading: 4
```

# Tiszt√°z√°sk√©ppen...

> Az ismertet≈ëk olvas√°sakor gyakran √ºtk√∂zhettek olyan paragrafusokba, mint ez a paragrafus is (balr√≥l beh√∫zott, szeg√©lyezett √©s sz√ºrk√©n √≠r√≥dott). Ezek megjegyz√©sek, fun factek, ismeretterjeszt≈ë bekezd√©sek. Nem k√∂telez≈ë elolvasni, sem a benn√ºk eml√≠tett dolgokat megtanulni - kiv√©ve ha am√∫gy is sz√≥ volt r√≥la el≈ëad√°son. Csup√°n a tud√°s m√©ly√≠t√©s√©√©rt, kieg√©sz√≠t√©sk√©nt, avagy extrak√©nt szolg√°lnak, ami fenntarthatja √©rdekl≈ëd√©seteket.

> Az adatb posztok elm√©l√©ti √∂sszefoglal√≥i ink√°bb az ismeretek ism√©tl√©s√©re √≠r√≥dtak, kev√©sb√© az alaposs√°g jegy√©ben, ink√°bb konyhanyelvet alkalmazva. √ârdemes lehet jegyzeteinket √©s/vagy a k√∂nyvet j√≥l √°tbogar√°szni egy vizsga el≈ëtt.

> **U.i.: ha esetleg hib√°t v√©ltek felfedezni ak√°rhol, b√°tran sz√≥ljatok r√°m gyakorlaton, vagy ki√°ltsatok r√°m email c√≠memen: [piller.trisztan@db.bme.hu](mailto:piller.trisztan@db.bme.hu).** K√∂szi.

# Elm√©leti √∂sszefoglal√≥

[Hivatalos jegyzet/k√∂nyv](https://db.bme.hu/~gajdos/Adatbazisok2019.pdf): 6. fejezet ismerend≈ë a gyakorlatra.

El≈ëz≈ë alkalommal [megismerkedt√ºnk azzal, mik√©nt is szervez≈ëdik meg fizikai szinten az adatb√°zisunk](/db/2021-10-16-adatb-3-gyakorlat/#elm√©leti-√∂sszefoglal√≥). A fizikai adatb√°zisunk _F√°jlmenedzser√©t_ viszont most m√°r nem fogjuk tov√°bb vizsg√°lni. üî¨

Most egy okoskod√≥s r√©sz√©hez √©r√ºnk a [DBMS](/db/2021-08-03-adatb-1-gyakorlat/#dbms)-nek: Visszat√©r√ºnk a _Lek√©rdez√©s feldolgoz√≥_ egys√©ghez, √©s annak a bonyolult bels≈ë m≈±k√∂d√©s√©t fogjuk k√∂zelebbr≈ël megvizsg√°lni, ugyanis az optimaliz√°l√≥ algoritmusait√≥l fognak f√ºggeni legink√°bb a _bonyolult lek√©r√©sek_ visszat√©r√©s√©nek idejei. ‚õ≥Ô∏è

## A lek√©rdez√©s feldolgoz√°sa

Ezen paragrafus tulajdonk√©ppen ism√©tl√©s, azonban most a _Lek√©rdez√©sfeldolgoz√≥_ modellj√©t finom√≠tjuk, √©s √∫jabb k√∂ztes munkafolyamatokat fogunk megismerni.

![dbms](/db/post1/dbms.png)

<div class="caption">√°bra: √°tlag DBMS m≈±k√∂d√©si s√©ma√°br√°ja, jelenleg m√°r az √°bra vil√°gosk√©k egys√©geivel is foglalkozunk!</div>

Ok√©: lek√ºldj√ºk a kalkulusban (teh√°t SQL-ben) megfogalmazott k√©r√©s√ºnket a DBMS-nek, √©s a DBMS azzal kihal√°ssza az adat√°llom√°nyb√≥l azt, ami nek√ºnk kell. Arr√≥l viszont hajlamosak vagyunk megfeledkezni, hogy ez **nem** ebb≈ël a k√©t l√©p√©sb≈ël √°ll, hanem:

1. a **kalkulusb√≥l** ugyanis el≈ësz√∂r a feldolgoz√≥ ford√≠t mag√°nak **rel√°ci√≥s algebrai kifejez√©st** (ez a _logikai m≈±veletsorozat_)
1. majd a **relalg kifejez√©st** okosan optimaliz√°lja (erre k√ºl√∂nf√©le heurisztik√°kkal √©lhet, DBMS-e v√°logatja), azaz:
   1. kiv√°lasztja a **megfelel≈ë fizikai algoritmusokat** a _logikai m≈±veletekre_ (pl.: joinok √©s szelekci√≥k sor√°n hogy kezelje majd a v√©grehajt√≥ modul a blokkokat)
   1. meghat√°rozza a legokosabb **sorrendj√©t a logikai m≈±veleteknek**
   1. v√©g√ºl az eg√©szet **munkafolyamatba** teszi (materializ√°ci√≥ √©s pipeline lehet ismert)
1. a fentiek eredm√©nye egy **v√©grehajt√°si terv**, amelyet ki kell √©rt√©kelni (van-e √©rtelme azt v√°lasztani), majd v√©grehajtani, azaz sorford√≠tani a _logikai m≈±veleteket fizikaira_, azaz **I/O m≈±veletekre** (pl.: READ, WRITE stb.)

Teh√°t √≠gy jutunk el a bonyolult SQL kifejez√©s√ºnkb≈ël a s√≠k egyszer≈± I/O m≈±veletek sor√°ig. Minket legink√°bb az √©rdekel, √©s azt szeretn√©nk megvizsg√°lni, hogy az optimaliz√°l√°s sor√°n milyen algoritmusok, milyen munkafolyamatok l√©teznek, √©s √°ltal√°ban milyen heurisztik√°val √©lnek a DBMS-ek, amikor √∫jrasorrendezik a logikai m≈±veleteket. Ezekr≈ël olvashatsz a tank√∂nyvben is. _A gyakorlat csup√°n a fizikai algoritmusokkal foglalkozik._ üß™

## Adatsz√≥t√°r

Mi van az **adatsz√≥t√°rban**? Tulajdonk√©ppen minden olyan handy dolog, ami j√≥l j√∂het a ki√©rt√©kel√©s √©s optimaliz√°l√°s elv√©gz√©s√©hez: sokf√©le meta adatok. T√∂bbek k√∂z√∂tt innen ismerhet≈ë meg egy-egy rel√°ci√≥n az egyes oszlopokra m√©rhet≈ë **Selection Cardinality** (`SC(A,r)`), azaz hogy egy k√∂z√∂ns√©ges szelekci√≥s lek√©r√©sn√©l (`pl.: SELECT * FROM r WHERE A = 5;`) v√°rhat√≥an h√°ny rekordot kaphatunk, valamint az **oszlopban v√°rhat√≥an h√°ny k√ºl√∂nb√∂z≈ë √©rt√©k** jelenhet meg (`V(A,r)`). Ezek alapj√°n √©p√ºl fel a **k√∂lts√©g-katal√≥gus** is!

## Algoritmusok

Az elm√©leti √∂sszefoglal√≥ ezen r√©sz√©t k√©z√≠r√°sba foglaltam, √©s olyan form√°tumban mutatom be az egyes algoritmusokat, ahogy a gyakorlaton is bemutattam (k√©rdez≈ëf√°val).

### Szelekci√≥ algoritmusai √©s azok l√©p√©ssz√°mai

![queryopt1.jpg](/db/post4/queryopt1.jpg) m√©g dolgozom rajta...

### Illeszt√©s algoritmusai √©s azok l√©p√©ssz√°mai

(Az egyes algoritmusok l√©p√©ssz√°m√°n√°l felt√©telezz√ºk, hogy a mem√≥ri√°ba csak 1-1 blokk f√©r be)

![queryopt2.jpg](/db/post4/queryopt2.jpg) m√©g dolgozom rajta...

El≈ëj√∂het az a gondolat a legt√∂bbj√ºkn√©l, hogy mi van, ha nem csak 1-1 blokkot tudunk a mem√≥ri√°ban t√°rolni a joinok sor√°n, ilyenkor pedig legt√∂bbj√ºkn√©l a [brbs.png](/db/post4/brbs.png) k√©plet lehet haszn√°lhat√≥. Hiszen gondoljunk csak bele, el√©g csup√°n beolvasni mindk√©t rel√°ci√≥t egyszer a mem√≥ri√°ba, ut√°na ak√°rmilyen CPU m≈±veletet v√©gezhet√ºnk vel√ºk, az ~0 millisecundumos id≈ëvel elv√©gezhet≈ë. üí°

# Feladatsor

## Feladatok

[Forr√°s](https://www.db.bme.hu/adatbazisok/files/optimalizalasgyak_2019.pdf).

###### 1. feladat: ismerked√©s a jel√∂l√©sekkel, katal√≥gusinform√°ci√≥k, algoritmusok haszn√°lata

Egy bank nyilv√°ntart√°s√°ban tal√°lhat√≥, SZ√ÅMLA(TELEP√úL√âS, EGYENLEG, ...) s√©m√°ra illeszked≈ë rel√°ci√≥b√≥l szeretn√©nk megtudni a budapesti sz√°ml√°k adatait. Ezeket tudjuk a rel√°ci√≥r√≥l:

```sh
- fSZ√ÅMLA = 40: SZ√ÅMLA rel√°ci√≥ 40 rekordja f√©r bele egy lemezblokkba.
- V (TELEP√úL√âS, SZ√ÅMLA) = 50: 50 k√ºl√∂nb√∂z≈ë fi√≥k-n√©v l√©tezik a SZ√ÅMLA rel√°ci√≥ban.
- V (EGYENLEG, SZ√ÅMLA) = 500: 500 k√ºl√∂nb√∂z≈ë √©rt√©k≈± sz√°mla van a SZ√ÅMLA rel√°ci√≥ban.
- nSZ√ÅMLA = 10 000: A SZ√ÅMLA rel√°ci√≥nak 10 000 eleme van.
```

A feladat megold√°sa sor√°n tegy√ºk fel, hogy a rel√°ci√≥ elemeit optim√°lis blokk-kihaszn√°lts√°g mellett t√°roljuk. K√©rd√©sek:

- a) Adjuk meg a feladatot megold√≥ rel√°ci√≥s algebrai lek√©rdez√©st!
- b) Mennyi minim√°lis/maxim√°lis/√°tlagos k√∂lts√©g, ha line√°ris keres√©st alkalmazunk? Mit≈ël f√ºgg, hogy mennyi?
- c) Tfh. a rekordok a fi√≥k szerint rendezetten t√°rol√≥dnak. Mennyi a bin√°ris keres√©s v√°rhat√≥ k√∂lts√©ge?

###### 2. feladat: a join nagys√°g√°nak becsl√©se

Adott k√©t rel√°ci√≥s s√©m√°nk, a BANKBET√âT √©s az √úGYF√âL. Illessz√ºk a k√©t (s√©m√°ra illeszked≈ë) rel√°ci√≥t a mindkett≈ëben szerepl≈ë √úGYF√âL_N√âV attrib√∫tum szerint, amely az √úGYF√âL kulcsa, a BANKBET√âT-ben pedig idegen kulcs. Tegy√ºk fel, hogy a k√©t rel√°ci√≥r√≥l a k√∂vetkez≈ë katal√≥gusinform√°ci√≥k √°llnak rendelkez√©sre:

```sh
- n√úGYF√âL = 10 000
- f√úGYF√âL = 25 b√úGYF√âL = ?
- nBANKBET√âT = 5 000
- fBANKBET√âT = 50, bBANKBET√âT = ?
- V(√úGYF√âL_N√âV, BANKBET√âT) = 2 500, SC(√úGYF√âL_N√âV, BANKBET√âT) = ?
```

- a) H√°ny olyan √ºgyf√©l van, akinek nincsen bankbet√©tje?
- b) Mekkora a BANKBET√âT √©s az √úGYF√âL term√©szetes illeszt√©s√©nek m√©rete, ha egyetlen k√∂z√∂s attrib√∫tumuk az √úGYF√âL_N√âV?
- c) √Åltal√°nos√≠tsuk a feladatot az al√°bbi esetekre (R √©s S az illesztend≈ë rel√°ci√≥k s√©m√°i, term√©szetes illeszt√©ssel)!
  - c.a) R ‚à© S = ‚àÖ.
  - c.b) R ‚à© S az R rel√°ci√≥ kulcsa.
  - c.c) R ‚à© S Ã∏= ‚àÖ egyik rel√°ci√≥s s√©m√°nak sem kulcsa.

###### 3. feladat: hash join k√∂lts√©ge

Sz√°m√≠tsd ki a ‚Äûhashjoin‚Äù algoritmussal v√©grehajtott join k√∂lts√©g√©t, ha v√∂dr√∂s hashel√©st alkalmazunk! A hash f√ºggv√©ny egyenletes eloszl√°ssal k√©pezi le a kulcsokat az √©rt√©kk√©szlet√©re. Hogyan √©rdemes a join-t v√©grehajtani? A blokkm√©ret nett√≥ 2 000 b√°jt, a hasht√°bla szok√°s szerint elf√©r a mem√≥ri√°ban.

- R rel√°ci√≥: 120 000 rekord, rekordhossz 150 b√°jt, kulcs 12 b√°jt, mutat√≥ 8 b√°jt, a hash t√°bla m√©rete 10 000 b√°jt.
- S rel√°ci√≥: 10 000 rekord, rekordhossz 250 b√°jt, kulcs 15 b√°jt, mutat√≥ 8 b√°jt a hash t√°bla m√©rete 1 000 b√°jt.

###### 4. feladat: index-alap√∫ illeszt√©s

Sz√°m√≠tsd ki az illeszt√©s k√∂lts√©g√©t, ha els≈ëdleges, B\*-fa strukt√∫r√°j√∫ indexeket haszn√°lhatunk a join attrib√∫tumok szerinti rekordel√©r√©sre! A blokkm√©ret nett√≥ 4 000 b√°jt. Melyik rel√°ci√≥ legyen a k√ºls≈ë hurokban? H√°nyszoros v√°laszid≈ët kapunk, ha az optimaliz√°l√≥ rosszul d√∂nt?

- R rel√°ci√≥: 140 000 rekord, rekordhossz 140 b√°jt, kulcs 10 b√°jt, mutat√≥ 4 b√°jt.
- S rel√°ci√≥: 15 000 rekord, rekordhossz 300 b√°jt, kulcs 6 b√°jt, mutat√≥ 4 b√°jt.

## H√°zi feladat

Amire √≥r√°n nem volt id≈ë. √ârdemes megn√©zni ZH el≈ëtt a tank√∂nyv h√°tulj√°ban l√©v≈ë feladatokat, legt√∂bbj√ºk el√©g j√≥l felk√©sz√≠t a ZH-ban el≈ëker√ºl≈ë dolgokra. T√∂bbsz√∂r √°tn√©zni √©s meg√©rteni, hogy melyik join algoritmus h√°ny iter√°ci√≥t v√©gez!

Ha tal√°ltok sz√°motokra tetsz≈ë feladatot a k√∂nyvben, megoldj√°tok, elk√ºldhetitek nekem a megold√°sotokat, hogy r√°pillantsak, j√≥nak t≈±nik-e. Ide emailezz: [piller.trisztan@db.bme.hu](mailto:piller.trisztan@db.bme.hu) No stress.

## Megold√°sok (√öJ!)

### 4. feladat megold√°sa

Okosan ki tudjuk sz√°molni blocking factor √©sat√∂bbi seg√≠ts√©g√©vel azt, hogy

- R rel√°ci√≥ 5000 blokkb√≥l √°ll
- S rel√°ci√≥ 1154 blokkb√≥l √°ll

Valamint egy j√≥lir√°nyzott:

![hti.png](/db/post4/hti.png)

...k√©plet haszn√°l√°val pedig kisz√°molhat√≥, hogy 2 szintes lesz mindk√©t esetben a B*-f√°nk. Azaz minden rekordel√©r√©sn√©l 2 blokkot kell a B*-f√°b√≥l, √©s +1-et kell olvasni az adatblokkokb√≥l (√∂sszesen 3-at).

Ugyeb√°r a fentiekb≈ël m√°r ismer≈ës lehet, hogyha **indexelt illeszt√©st** haszn√°lunk

- R rel√°ci√≥ a k√ºls≈ë hurokban van, akkor k√©plet√ºnk a lenti lesz (v√©geredm√©ny: 425000 l√©p√©s)
  - ![br.png](/db/post4/br.png)
- S rel√°ci√≥ a k√ºls≈ë hurokban van, akkor k√©plet√ºnk a lenti lesz (v√©geredm√©ny: 46154 l√©p√©s, ≈ë nyer)
  - ![bs.png](/db/post4/bs.png)

Viszont ha az optimaliz√°l√≥ nem csak **indexelt illeszt√©st** v√°laszthatna ezeken a rel√°ci√≥kon, mi juthat esz√ºnkbe? Vegy√ºk figyelembe a feladat ezen mondat√°t: _"...ha **els≈ëdleges**, B\*-fa strukt√∫r√°j√∫ indexeket haszn√°lhatunk a join attrib√∫tumok szerinti rekordel√©r√©sre..."_ Hopp√°! Hiszen **els≈ëdleges** az index mindk√©t rel√°ci√≥n √âS (fontos hogy √âS) az mindk√©t index √©ppenhogy az alapj√°n az attrib√∫tum alapj√°n √©p√ºlt, amit most a joinban is haszn√°lunk!

Ford√≠tsuk le magyarra m√©gegyszer: A join k√∂z√∂s attrib√∫tuma legyen `A`. R rel√°ci√≥n van egy B*-fa, aminek az `A` attrib√∫tum a keres√©si kulcsa. S rel√°ci√≥n van egy B*-fa, aminek az `A` attrib√∫tum a keres√©si kulcsa. Mindk√©t B\*-fa els≈ëdleges index. Az els≈ëdleges index defin√≠ci√≥ja pedig pontosan az, hogy az indexrekordok olyan olvas√°s√°t teszi lehet≈ëv√©, hogy az olvasott sorrend megegyezik az adatblokkok t√°rol√°si sorrendj√©vel -> Az adat√°llom√°nyban a rekordok √©ppen az `A` alapj√°n vannak **rendezve**.

Emelj√ºk ki a t√©nyt, hogy **rendezett** az adat√°llom√°nyunk. Ez a t√©ny lehet≈ës√©get ad arra, hogy **merge join**-t (√∂sszef√©s√ºl√©ses illeszt√©st) haszn√°ljunk az indexeltek helyett! üéä üéâ

**Merge join** eset√©n pedig a k√©plet√ºnk sokkal egyszer≈±bb lesz, csup√°n a k√©t rel√°ci√≥ blokkjainak sz√°m√°t kell √∂sszeadnunk (v√©geredm√©ny: 6154 l√©p√©s, ≈ë nyer v√©g√ºl), hiszen a f√©s√ºl√©ses join csak megyeget a blokkokon √©s f√©s√ºlgeti ≈ëket, ha van egyez√©s `A` attrib√∫tum alapj√°n.
